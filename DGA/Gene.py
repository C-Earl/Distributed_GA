import inspect
import time
import numpy as np
from abc import abstractmethod


### Initializers ###
class base_init_class:
  def run(self, shape: tuple) -> any:
    pass


class uniform_initialization(base_init_class):
  def __init__(self, min_val: float, max_val: float):
    self.min_val = min_val
    self.max_val = max_val

  def run(self, shape: tuple) -> np.ndarray:
    return np.random.uniform(low=self.min_val, high=self.max_val, size=shape)


class normal_initialization(base_init_class):
  def __init__(self, loc: float, scale: float):
    self.loc = loc
    self.scale = scale

  def run(self, shape: tuple) -> np.ndarray:
    return np.random.normal(loc=self.loc, scale=self.scale, size=shape)


### Mutation Functions ###
class base_mutate_class:
  def __init__(self, mutation_rate: float, decay: float = 1.0):
    self.mutation_rate = mutation_rate
    self.decay = decay

  def run(self, param: np.ndarray) -> np.ndarray:
    pass

  def decay_mutation_rate(self):
    self.mutation_rate *= self.decay


class no_mutation(base_mutate_class):
  def run(self, param: np.ndarray) -> np.ndarray:
    return param


class normal_mutation(base_mutate_class):
  def __init__(self, loc: float, scale: float, mutation_rate: float, decay: float = 1.0):
    super().__init__(mutation_rate, decay)
    self.loc = loc
    self.scale = scale

  def run(self, param: np.ndarray,) -> np.ndarray:
    if np.random.rand() < self.mutation_rate:
      return param + np.random.normal(loc=self.loc, scale=self.scale, size=param.shape)
    else:
      return param


class uniform_mutation(base_mutate_class):
  def __init__(self, min_val: float, max_val: float, mutation_rate: float, decay: float = 1.0):
    super().__init__(mutation_rate, decay)
    self.min_val = min_val
    self.max_val = max_val

  def run(self, param: np.ndarray) -> np.ndarray:
    if np.random.rand() < self.mutation_rate:
      return param + np.random.uniform(low=self.min_val, high=self.max_val, size=param.shape)
    else:
      return param


class splice_mutation(base_mutate_class):
  def __init__(self, mutation_rate: float, mutation_size: int, decay: float = 1.0, loc: float = 0, scale: float = 1):
    super().__init__(mutation_rate, decay)
    self.mutation_size = mutation_size
    self.loc = loc
    self.scale = scale

  def run(self, param: np.ndarray) -> np.ndarray:
    org_shape = param.shape
    if np.random.rand() < self.mutation_rate:
      mutation_start = np.random.randint(0, np.prod(param.shape))
      mutation_end = np.random.randint(mutation_start+1, mutation_start+2+self.mutation_size)
      if mutation_end > np.prod(param.shape):
        mutation_end = np.prod(param.shape)
      param = param.flatten()
      param[mutation_start:mutation_end] += np.random.normal(loc=self.loc, scale=self.scale, size=mutation_end-mutation_start)
      return param.reshape(org_shape)
    else:
      return param


### Crossover Functions ###
class base_crossover_class:
  def run(self, parents: list[np.ndarray]) -> np.ndarray:
    pass


class mean_crossover(base_crossover_class):
  def run(self, parents: list[np.ndarray]) -> np.ndarray:
    return np.mean(parents, axis=0)


class splice_crossover(base_crossover_class):
  def run(self, parents: list[np.ndarray]) -> np.ndarray:
    p1, p2 = parents[0], parents[1]
    full_index = np.prod(p1.shape)
    splice = np.random.randint(low=0, high=full_index)
    new_param = np.concatenate([p1.flatten()[:splice], p2.flatten()[splice:]])
    return new_param.reshape(p1.shape)


# Numerical representation of a Genome
# Generated by Genome, used to populate Model
class Parameters(dict):
  def __init__(self, iteration: int, values: dict = None,  # Numerical values as {gene_name: np.ndarray}
               fitness: float = None):
    super().__init__()
    self.iteration = iteration
    self.fitness = fitness
    self.timestamp = time.strftime('%H:%M:%S', time.localtime())

    if values is not None:
      self.update(values)  # Add values to self (dict)

    # Set hash (timestamp + iteration should be unique)
    hashable_obj = tuple([self.timestamp, self.iteration])
    self.hash_ = hash(hashable_obj)

    # Set tested flag if fitness provided
    if self.fitness is None:
      self.tested_ = False
    else:
      self.tested_ = True

  def as_array(self) -> np.ndarray:
    return np.concatenate([param.flatten() for param in self.values()])

  def set_fitness(self, fitness: float):
    self.fitness = fitness
    self.tested_ = True

  def set_iteration(self, iteration: int):
    self.iteration = iteration

  def set_timestamp(self, timestamp: float):
    self.timestamp = timestamp

  def set_tested(self, tested: bool):
    self.tested_ = tested

  def tested(self) -> bool:
    return self.tested_

  def set_attribute(self, name: str, value: any):
    setattr(self, name, value)

  def __hash__(self):
    return self.hash_


class Gene():
  def __init__(self,
               shape: tuple,
               dtype: type,
               default: any = None,
               min_val: float = -1,
               max_val: float = +1,
               **kwargs):
    self.shape = shape
    self.dtype = dtype
    self.default = default
    self.min_val = min_val
    self.max_val = max_val
    for key, val in kwargs.items():
      setattr(self, key, val)
    super().__init__()

  def to_json(self):
    attributes = {key: val for key, val in self.__dict__.items()}
    attributes['dtype'] = str(attributes['dtype'])
    return attributes


# During
# Take in set of genes, turn them
class Genome(dict):
  def __init__(self):
    super().__init__()

  def add_gene(self, gene: Gene, name: str):
    self[name] = gene

  # Called when a new Parameters is needed, and no other Parameters in pool
  # Inputs: iteration
  # Outputs: new Parameters
  def initialize(self, iteration: int) -> Parameters:
    new_params = Parameters(iteration=iteration)
    for gene_name, gene in self.items():
      gdefault = gene.default
      if gdefault is not None:    # If default value is provided, use it
        new_params[gene_name] = gdefault
      else:
        gshape = gene.shape       # Otherwise, uniform generate values in gene range
        gmin = gene.min_val
        gmax = gene.max_val
        gtype = gene.dtype
        new_params[gene_name] = np.random.uniform(low=gmin, high=gmax, size=gshape).astype(gtype)
    return new_params

  # Takes in a Parameters object and mutates it (Note: Returns same Parameters object)
  # Inputs: Parameters
  # Outputs: Parameters (mutated)
  def mutate(self, params: Parameters) -> Parameters:
    for gene_name, gene in self.items():
      gshape = gene.shape
      gtype = gene.dtype      # Apply uniform mutation to each gene
      params[gene_name] += np.random.uniform(low=-1, high=+1, size=gshape).astype(gtype)
    return params

  # Takes in a Parameters object and crosses it with another Parameters object
  # Inputs: list of Parameters (parents)
  # Outputs: Parameters (offspring)
  def crossover(self, parents: list[Parameters], iteration: int) -> Parameters:
    p1, p2 = parents[0], parents[1]  # Only two parents used for now, change later
    child_params = Parameters(iteration=iteration)
    for gene_name, gene in self.items():
      gshape = p1[gene_name].shape
      full_index = np.prod(gshape)
      splice = np.random.randint(low=0, high=full_index)
      new_param = np.concatenate([p1[gene_name].flatten()[:splice], p2[gene_name].flatten()[splice:]])
      child_params[gene_name] = new_param.reshape(gshape)
    return child_params
