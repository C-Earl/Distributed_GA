import numpy as np

# Numerical representation of a Genome
# Generated by Genome, used to populate Model
class Parameters(dict):
  def __init__(self, **kwargs):
    super().__init__()
    self.fitness = None
    self.iteration = None
    self.timestamp = None
    self.values = {}  # Stores numerical values as {gene_name: np.ndarray}
    self.update(**kwargs)


# Collection of Genes, uses Genes to generate Parameters
class Genome(dict):
  def __init__(self, **genes) -> None:
    super().__init__()
    for name, gene in genes.items():
      gene.name = name
      self[name] = gene

  def initialize(self) -> Parameters:
    new_params = Parameters()
    for gene in self.values():
      gene.initialize()


# Gene, a subsection of a Genome.
# Used to store information about how that subsection behaves
class Gene:
  def __init__(self,
               min: float | dict, max: float | dict,
               shape: tuple | dict,
               type: type,
               default: float | dict = None,
               mutation_rate: float = 0.1,
               fitness: float = None,
               initializer: callable = None) -> None:
    self.min = min
    self.max = max
    self.shape = shape
    self.type = type
    self.default = default
    self.mutation_rate = mutation_rate
    self.fitness = fitness
    self.initialize = initializer

  def initialize(self):
    # Initialize gene value
    if self.default is not None:  # Use default value if provided
      return self.default
    else:
      return np.random.uniform(low=self.min, high=self.max, size=self.shape).astype(self.type)


if __name__ == '__main__':
  g = Gene(min=0,
              max=10,
              shape=(2, 2),
              type=float,
              initializer=lambda g: np.random.uniform(low=g.min, high=g.max, size=g.shape).astype(g.type))
  g.initialize()