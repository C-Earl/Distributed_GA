import numpy as np
import inspect
import time


# Numerical representation of a Genome
# Generated by Genome, used to populate Model
class Parameters(dict):
    def __init__(self, iteration: int, values: dict = None,  # Numerical values as {gene_name: np.ndarray}
                 fitness: float = None):
        super().__init__()
        self.iteration = iteration
        self.fitness = fitness
        self.timestamp = time.strftime('%H:%M:%S', time.localtime())

        if values is not None:
            self.update(values)  # Add values to self (dict)

        # Set tested flag if fitness provided
        if self.fitness is None:
            self.tested_ = False
        else:
            self.tested_ = True

    def set_fitness(self, fitness: float):
        self.fitness = fitness

    def set_iteration(self, iteration: int):
        self.iteration = iteration

    def set_timestamp(self, timestamp: float):
        self.timestamp = timestamp

    def set_values(self, values: dict):
        self.values = values

    def set_tested(self, tested: bool):
        self.tested_ = tested

    def tested(self) -> bool:
        return self.tested_


# Gene, a subsection of a Genome.
# Used to store information about how that subsection behaves
class Gene:
    def __init__(self,
                 min_val: float = None, max_val: float = None,  # Range of gene values
                 shape: tuple = None,  # Shape of gene values
                 datatype: type = None,  # Type for gene values
                 default: any = None,  # Initial value for gene
                 mutation_rate: float = None,  # Mutation rate for gene
                 fitness: float = None,  # Fitness of gene
                 initializer: callable = None,  # User defined initializer
                 mutator: callable = None,  # User defined mutator
                 crossover: callable = None,  # User defined crossover
                 ) -> None:
      self.min_val = min_val
      self.max_val = max_val
      self.shape = shape
      self.type = datatype
      self.default = default
      self.mutation_rate = mutation_rate
      self.fitness = fitness

      # User defined functions (called in respective wrapper functions below)
      self.initialize_ = initializer
      self.mutate_ = mutator
      self.crossover_ = crossover

      # Get names of args (set by user) for each function
      self.init_arg_names = inspect.getfullargspec(self.initialize_).args if self.initialize_ else None
      self.mutate_arg_names = inspect.getfullargspec(self.mutate_).args if self.mutate_ else None
      self.crossover_arg_names = inspect.getfullargspec(self.crossover_).args if self.crossover_ else None

      # Always provided as arguments, so remove from arg lists
      self.mutate_arg_names.remove('params') if self.mutate_arg_names else None
      self.crossover_arg_names.remove('params_list') if self.crossover_arg_names else None
      self.crossover_arg_names.remove('iteration') if self.crossover_arg_names else None

    # Wrapper to send right args to initializer
    # Returns initialized gene value
    # kwargs used to contain upstream args from genome
    def initialize(self, **kwargs) -> np.ndarray:
      # Initialize gene value
      if self.default is not None:  # Use default value if provided
        return self.default
      else:

        # Create arg list (Gene-level args (self) priority over Genome-level (kwargs))
        for arg in self.init_arg_names:
          if arg in self.__dict__ and getattr(self, arg) is not None:  # Override with gene arg if provided
            kwargs[arg] = getattr(self, arg)
          elif arg in kwargs:   # Use genome arg if provided
            continue
          else:
            raise AttributeError(f'Gene is missing required arg \'{arg}\' for initialization')

        # Return initialized value
        return self.initialize_(**kwargs)

    # Wrapper function for gene-level mutation
    # Takes in param value, returns mutated gene value
    # Returns None if no user provided mutator func
    def mutate(self, params: np.ndarray, **kwargs) -> np.ndarray:
      # Create arg list (Gene-level args (self) priority over Genome-level (kwargs))
      for arg in self.mutate_arg_names:
        if arg in self.__dict__ and getattr(self, arg) is not None:  # Override with gene arg if provided
          kwargs[arg] = getattr(self, arg)
        elif arg in kwargs:  # Use genome arg if provided
          continue
        else:
          raise AttributeError(f'Gene is missing required arg \'{arg}\' for mutation')

      # Return mutated value
      return self.mutate_(params, **kwargs)

    # Wrapper function for gene-level crossover
    # Takes in list of param values, returns new crossed-over gene
    # Returns None if no user provided crossover func
    def crossover(self, params_list: list[Parameters], iteration: int) -> np.ndarray:
      return self.crossover_(params_list, iteration)


# Collection of Genes, uses Genes to generate Parameters
class Genome(Gene, dict):
    def __init__(self,    # Same args as Gene, see above
                 min_val: float = None, max_val: float = None,
                 shape: tuple = None,
                 datatype: type = None,
                 default: np.ndarray = None,
                 mutation_rate: float = None,
                 fitness: float = None,
                 initializer: callable = None,
                 mutator: callable = None,
                 crossover: callable = None,
                 # override_genes: bool = False   # If True, args above override gene args IF they are None
                 ) -> None:
      super().__init__(min_val, max_val, shape, datatype, default, mutation_rate, fitness, initializer, mutator,
                       crossover)

    def add_gene(self, name: str, gene: Gene):
      self[name] = gene

    # Initialize all genes in genome
    # Prioritize gene-level intialization. If not provided, use genome-level initializer
    def initialize(self, iteration: int) -> Parameters:
      new_params = Parameters(iteration=iteration)
      for gene_name, gene in self.items():

        # Check gene-level default
        if gene.default is not None:
          new_params[gene_name] = gene.default

        # Check gene-level initializer
        elif gene.initialize_:
          # Pass down genome-level args
          init_args = {arg_name: getattr(self, arg_name) if arg_name in self else None
                       for arg_name in gene.init_arg_names}
          new_params[gene_name] = gene.initialize(**init_args)

        # Check genome-level default
        elif self.default is not None:
          new_params[gene_name] = self.default

        # Check genome-level initializer
        elif self.initialize_:
          init_args = {}  # Create args (gene-level args priority over genome-level)
          for arg_name in self.init_arg_names:
            if arg_name in gene.__dict__ and getattr(gene, arg_name) is not None:
              init_args[arg_name] = getattr(gene, arg_name)
            elif arg_name in self.__dict__ and getattr(self, arg_name) is not None:
              init_args[arg_name] = getattr(self, arg_name)
            else:
              raise AttributeError(f'Genome is missing required initializer arg \'{arg_name}\' for gene \'{gene_name}\'')
          new_params[gene_name] = self.initialize_(**init_args)

        else:
          raise AttributeError(f'Gene \'{gene_name}\' is missing initializer')
      return new_params

    # Mutate all genes in given parameters according to gene-level mutation logic
    # If no gene-level mutation logic, no mutation occurs here
    # Takes in params, returns mutated params (same object)
    def mutate(self, params: Parameters) -> Parameters:
      for gene_name, gene in self.items():

        # Check gene-level mutate
        if gene.mutate_:
          # Pass down genome-level args
          mutate_args = {arg_name: getattr(self, arg_name) if arg_name in self else None
                         for arg_name in gene.mutate_arg_names}
          params[gene_name] = gene.mutate(params[gene_name], **mutate_args)

        # Check genome-level mutate
        elif self.mutate_:
          mutate_args = {}  # Create args (gene-level args priority over genome-level)
          for arg_name in self.mutate_arg_names:
            if arg_name in gene.__dict__ and getattr(gene, arg_name) is not None:
              mutate_args[arg_name] = getattr(gene, arg_name)
            elif arg_name in self.__dict__ and getattr(self, arg_name) is not None:
              mutate_args[arg_name] = getattr(self, arg_name)
            else:
              raise AttributeError(f'Genome is missing required mutator arg \'{arg_name}\' for gene \'{gene_name}\'')
          params[gene_name] = self.mutate_(params[gene_name], **mutate_args)

        else:
          raise AttributeError(f'Gene \'{gene_name}\' is missing mutator')
      return params

    # Crossover all genes in given parameters according to gene-level crossover logic
    # If no gene-level crossover logic, no crossover occurs here
    # Takes in params, returns new crossed-over params
    def crossover(self, parents: list[Parameters], iteration: int) -> Parameters:
      new_params = Parameters(iteration=iteration)
      for gene_name, gene in self.items():

        # Check gene-level crossover
        if gene.crossover_:
          # Pass down genome-level args
          crossover_args = {arg_name: getattr(self, arg_name) if arg_name in self else None
                         for arg_name in gene.crossover_arg_names}
          parent_genes = [parent[gene_name] for parent in parents]
          new_params[gene_name] = gene.crossover(parent_genes, iteration, **crossover_args)

        # Check genome-level crossover
        elif self.crossover_:
          crossover_args = {}  # Create args (gene-level args priority over genome-level)
          for arg_name in self.crossover_arg_names:
            if arg_name in gene.__dict__ and getattr(gene, arg_name) is not None:
              crossover_args[arg_name] = getattr(gene, arg_name)
            elif arg_name in self.__dict__ and getattr(self, arg_name) is not None:
              crossover_args[arg_name] = getattr(self, arg_name)
            else:
              raise AttributeError(f'Genome is missing required crossover arg \'{arg_name}\' for gene \'{gene_name}\'')
          parent_genes = [parent[gene_name] for parent in parents]
          new_params[gene_name] = self.crossover_(parent_genes, iteration, **crossover_args)

        else:
          raise AttributeError(f'Gene \'{gene_name}\' is missing crossover')
      return new_params


if __name__ == '__main__':
    genome = Genome(min_val=0, max_val=1, shape=(2, 2), datatype=float, mutation_rate=1,
                    initializer=lambda min_val, max_val, shape: np.random.uniform(low=min_val, high=max_val, size=shape),
                    mutator=lambda params, mutation_rate: params + np.random.normal(loc=0, scale=mutation_rate, size=params.shape),
                    crossover=lambda params_list, iteration: np.mean(params_list, axis=0))
    gene1 = Gene(min_val=-10, max_val=20, shape=(1, 3), mutation_rate=1, datatype=int)
    gene2 = Gene(mutation_rate=1000, initializer=lambda mutation_rate: mutation_rate,
                 mutator=lambda params, mutation_rate: params + mutation_rate)
    gene3 = Gene(shape=(1,), default=np.array([13]))
    genome.add_gene('gene1', gene1)
    genome.add_gene('gene2', gene2)
    genome.add_gene('gene3', gene3)
    params = genome.initialize(iteration=0)
    print(params)
    mutated_params = genome.mutate(params)
    print(params)
    params2 = genome.initialize(iteration=1)
    print(f"p2: {params2}")
    print(f"p1: {params}")
    crossover_params = genome.crossover([params, params2], iteration=2)
    print(f"cross: {crossover_params}")
